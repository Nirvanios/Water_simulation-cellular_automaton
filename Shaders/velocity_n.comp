#version 450


#define NO_FLAG 0
#define CELL_SOLID 1
#define CELL_SOURCE 2
#define CELL_SINK 4
#define FLOW_DOWN 8

struct CellData{
    vec3 velocity;
    float fluidVolume;
};

struct CellInfo{
    vec4 reflectA;
    vec4 reflectB;
    int flags;
};

layout(local_size_x = 2, local_size_y = 2, local_size_z = 2) in;
layout(std430, binding=0) buffer WriteBuffer{
    CellData writeCells[];
};
layout(std430, binding=1) buffer ReadBuffer{
    CellData readCells[];
};
layout(std430, binding=2) buffer InfoBuffer{
    CellInfo infoCells[];
};

uvec3 globalSize = uvec3(gl_NumWorkGroups.x * gl_WorkGroupSize.x, gl_NumWorkGroups.y * gl_WorkGroupSize.y, gl_NumWorkGroups.z * gl_WorkGroupSize.z);

const float maximumCellVolume = 1.0;
const float minimumCellVolume = 0.005;
const float maximumCompression = 0.0;
const float maximumFlow = 4.0f;
const uint verticalNeighbourSize = 4;
const ivec3 neighbourOffsets[4] = { ivec3(-1, 0, 0), ivec3(1, 0, 0), ivec3(0, 0, -1), ivec3(0, 0, 1) };

int to1DCoord(uvec3 coord){
    return int(coord.z * globalSize.x * globalSize.y + coord.y * globalSize.x + coord.x);
}

const float waterWeight = 1;
const float timeStep = 0.01;
float getDragCoefficient() {
    return 0.99;
}

vec3 getGlobalForces() {
    vec3 gravity = vec3(0, -9.81, 0);
    vec3 current = vec3(0, 0, 0);
    return (gravity + current) * timeStep;
}

bool isFull(float volume) {
    return volume >= 1.0f;
}

float getRatioNeighbor(CellData currentCell, CellData neighbor) {
    return (currentCell.fluidVolume + neighbor.fluidVolume) / neighbor.fluidVolume;
}


#define LEFT 0
#define RIGHT 1
#define UP 2
#define DOWN 3
#define FRONT 4
#define BACK 5
float getNeighborVel(CellData cell, int direction) {
    switch (direction) {
        case LEFT:
        return float(cell.velocity.x < 0) * cell.velocity.x;
        case RIGHT:
        return float(cell.velocity.x > 0) * cell.velocity.x;
        case UP:
        return float(cell.velocity.y > 0) * cell.velocity.y;
        case DOWN:
        return float(cell.velocity.y < 0) * cell.velocity.y;
        case FRONT:
        return float(cell.velocity.z < 0) * cell.velocity.z;
        case BACK:
        return float(cell.velocity.z > 0) * cell.velocity.z;
    }
    return 0;
}

bool isFlagSet(int flags, int flag) {
    return (flags & flag) == flag;
}

vec3 reflectVelocity(vec3 velocity, vec3 normal) {
    vec3 reflected = reflect(velocity, normal);
    return reflected;
}

uint upperCellID = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + (gl_GlobalInvocationID.y + 1) * globalSize.x + gl_GlobalInvocationID.x;
uint bottomCellID = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + (gl_GlobalInvocationID.y - 1) * globalSize.x + gl_GlobalInvocationID.x;
uint frontCellID = (gl_GlobalInvocationID.z - 1) * globalSize.x * globalSize.y + globalSize.x + gl_GlobalInvocationID.x;
uint backCellID = (gl_GlobalInvocationID.z + 1) * globalSize.x * globalSize.y + globalSize.x + gl_GlobalInvocationID.x;
uint leftCellID =  gl_GlobalInvocationID.z * globalSize.x * globalSize.y + globalSize.x + gl_GlobalInvocationID.x - 1;
uint rightCellID = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + globalSize.x + gl_GlobalInvocationID.x + 1;

uint getNeighborID(int direction) {
    switch (direction) {
        case LEFT: return upperCellID;
        case RIGHT: return bottomCellID;
        case UP: return frontCellID;
        case DOWN: return backCellID;
        case FRONT: return leftCellID;
        case BACK: return rightCellID;
    }
    return 0;
}

vec3 getNormal(int direction) {
    switch (direction) {
        case LEFT: return vec3(-1, 0, 0);
        case RIGHT: return vec3(1, 0, 0);
        case UP: return vec3(0, 1, 0);
        case DOWN: return vec3(0, -1, 0);
        case FRONT: return vec3(0, 0, 1);
        case BACK: return vec3(0, 0, -1);
    }
    return vec3(0, 0, 0);
}

vec3 getSpread(int direction) {
    const float spreadValue = 0.1;
    switch (direction) {
        case RIGHT:
        case LEFT: return vec3(0, spreadValue, spreadValue);
        case UP:
        case DOWN: return vec3(spreadValue, 0, spreadValue);
        case FRONT:
        case BACK: return vec3(spreadValue, spreadValue, 0);
    }
    return vec3(0, 0, 0);
}

void main() {
    uvec3 globalSize = uvec3(gl_NumWorkGroups.x * gl_WorkGroupSize.x, gl_NumWorkGroups.y * gl_WorkGroupSize.y, gl_NumWorkGroups.z * gl_WorkGroupSize.z);
    uint myCellID = (gl_GlobalInvocationID.z * globalSize.x * globalSize.y)+ (gl_GlobalInvocationID.y * globalSize.x) + gl_GlobalInvocationID.x;
    uint invocationCount = globalSize.x * globalSize.y * globalSize.z;
    if (myCellID >= invocationCount){
        return;
    }

    writeCells[myCellID].velocity = (readCells[myCellID].velocity + getGlobalForces());
    writeCells[myCellID].velocity += getRatioNeighbor(readCells[myCellID], readCells[rightCellID]) * getNeighborVel(readCells[rightCellID], LEFT);
    writeCells[myCellID].velocity += getRatioNeighbor(readCells[myCellID], readCells[leftCellID]) * getNeighborVel(readCells[leftCellID], RIGHT);
    writeCells[myCellID].velocity += getRatioNeighbor(readCells[myCellID], readCells[backCellID]) * getNeighborVel(readCells[backCellID], FRONT);
    writeCells[myCellID].velocity += getRatioNeighbor(readCells[myCellID], readCells[frontCellID]) * getNeighborVel(readCells[frontCellID], BACK);
    writeCells[myCellID].velocity += getRatioNeighbor(readCells[myCellID], readCells[bottomCellID]) * getNeighborVel(readCells[bottomCellID], UP);
    writeCells[myCellID].velocity += getRatioNeighbor(readCells[myCellID], readCells[upperCellID]) * getNeighborVel(readCells[upperCellID], DOWN);
    writeCells[myCellID].velocity *= getDragCoefficient();
    writeCells[myCellID].velocity *= float(isFlagSet(infoCells[myCellID].flags, CELL_SOLID));

    int cntUsed = 0;
    vec3 reflect = vec3(0);
    infoCells[myCellID].reflectA = vec3(0);
    infoCells[myCellID].reflectB = vec3(0);

    vec3 tmpReflectA = vec3(0);
    vec3 tmpReflectB = vec3(0);
    for (int i = 0; i < 6; ++i) {
        const uint neighborID = getNeighborID(i);
        if (isFlagSet(infoCells[myCellID].flags, CELL_SOLID)
        || readCells[neighborID].fluidVolume >= maximumCellVolume) {
            reflect = reflectVelocity(velocity, getNormal(i));
            infoCells[myCellID].reflectA += vec3(
            reflect.x * float(reflect.x > 0),
            reflect.y * float(reflect.y > 0),
            reflect.z * float(reflect.z > 0)
            );
            infoCells[myCellID].reflectB += vec3(
            reflect.x * float(reflect.x < 0),
            reflect.y * float(reflect.y < 0),
            reflect.z * float(reflect.z < 0)
            );

            tmpReflectA += getSpread(i);
            tmpReflectb -= getSpread(i);
            ++cntUsed;
        }
    }
    if (cntUsed > 0) {
        infoCells[myCellID].reflectA /= cntUsed;
        infoCells[myCellID].reflectB /= cntUsed;
        infoCells[myCellID].reflectA += tmpReflectA;
        infoCells[myCellID].reflectB += tmpReflectB;
    }
}