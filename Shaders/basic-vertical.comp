#version 450

struct Cell{
    float fluidVolume;
    uint stable;
};

struct DrawElementsIndirectCommand{
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};


layout(local_size_x = 2, local_size_y = 2, local_size_z = 2) in;
layout(std430, binding=0) buffer WriteBuffer{
    Cell writeCells[];
};
layout(std430, binding=1) buffer ReadBuffer{
    Cell readCells[];
};
layout(std430, binding=2) buffer Positions{
    vec4 positions[];
};
layout(std430, binding=3) buffer DrawArrays{
    DrawElementsIndirectCommand drawArray;
};

uvec3 globalSize = uvec3(gl_NumWorkGroups.x * gl_WorkGroupSize.x, gl_NumWorkGroups.y * gl_WorkGroupSize.y, gl_NumWorkGroups.z * gl_WorkGroupSize.z);

const float maximumCellVolume = 1.0;
const float minimumCellVolume = 0.005;
const float maximumCompression = 0.25;
const float maximumFlow = 4.0f;
const uint verticalNeighbourSize = 4;
const ivec3 neighbourOffsets[4] = { ivec3(-1, 0, 0), ivec3(1, 0, 0), ivec3(0, 0, -1), ivec3(0, 0, 1) };

int to1DCoord(uvec3 coord){
    return int(coord.z * globalSize.x * globalSize.y + coord.y * globalSize.x + coord.x);
}

float horizontalFlowVolume(float sourceFluidVolume, float destinationFluidVolume){
    if (sourceFluidVolume > destinationFluidVolume){
        return clamp((sourceFluidVolume - destinationFluidVolume) / float(verticalNeighbourSize + 1), 0, sourceFluidVolume / float(verticalNeighbourSize + 1));
    }
    return 0.0;
}

void main() {
    uint myCellID = (gl_GlobalInvocationID.z * globalSize.x * globalSize.y)+ (gl_GlobalInvocationID.y * globalSize.x) + gl_GlobalInvocationID.x;
    uint invocationCount = globalSize.x * globalSize.y * globalSize.z;
    if (myCellID < invocationCount){
            float inFlow = 0.0;
            float outFlow = 0.0;
            for (int offsetIndex = 0; offsetIndex < verticalNeighbourSize; ++offsetIndex){
                ivec3 currentNeighbour = ivec3(gl_GlobalInvocationID) + neighbourOffsets[offsetIndex];
                if (all(greaterThanEqual(currentNeighbour, ivec3(0))) && all(lessThan(currentNeighbour, globalSize))){
                    inFlow += horizontalFlowVolume(readCells[to1DCoord(currentNeighbour)].fluidVolume, readCells[myCellID].fluidVolume);
                    outFlow += horizontalFlowVolume(readCells[myCellID].fluidVolume, readCells[to1DCoord(currentNeighbour)].fluidVolume);
                }
            }
            writeCells[myCellID].fluidVolume = readCells[myCellID].fluidVolume + (inFlow - outFlow);
    }

    if (myCellID < invocationCount){
        if (writeCells[myCellID].fluidVolume > 0.0){
            uint positionID = atomicAdd(drawArray.instanceCount, 1u);
            positions[positionID] = vec4(gl_GlobalInvocationID, 0.0);
        }
    }

}
