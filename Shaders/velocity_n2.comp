#version 450


#define NO_FLAG 0
#define CELL_SOLID 1
#define CELL_SOURCE 2
#define CELL_SINK 4
#define FLOW_DOWN 8

struct CellData{
    vec3 velocity;
    float fluidVolume;
};

struct CellInfo{
    vec4 reflectA;
    vec4 reflectB;
    int flags;
};

layout(local_size_x = 4,
local_size_y = 4,
local_size_z = 4
) in;
layout(std430, binding=0) buffer WriteBuffer{
    CellData writeCells[];
};
layout(std430, binding=1) buffer ReadBuffer{
    CellData readCells[];
};
layout(std430, binding=2) buffer InfoBuffer{
    CellInfo infoCells[];
};

layout(location = 0) uniform uvec3 globalSize;

const float maximumCellVolume = 1.0;
const float minimumCellVolume = 0.005;
const float maximumCompression = 0.0;
const float maximumFlow = 4.0f;
const uint verticalNeighbourSize = 4;
const ivec3 neighbourOffsets[4] = { ivec3(-1, 0, 0), ivec3(1, 0, 0), ivec3(0, 0, -1), ivec3(0, 0, 1) };



#define LEFT 0
#define RIGHT 1
#define UP 2
#define DOWN 3
#define FRONT 4
#define BACK 5

uint upperCellID = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + (gl_GlobalInvocationID.y + 1) * globalSize.x + gl_GlobalInvocationID.x;
uint bottomCellID = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + (gl_GlobalInvocationID.y - 1) * globalSize.x + gl_GlobalInvocationID.x;
uint frontCellID = (gl_GlobalInvocationID.z - 1) * globalSize.x * globalSize.y + gl_GlobalInvocationID.y * globalSize.x + gl_GlobalInvocationID.x;
uint backCellID = (gl_GlobalInvocationID.z + 1) * globalSize.x * globalSize.y + gl_GlobalInvocationID.y * globalSize.x + gl_GlobalInvocationID.x;
uint leftCellID =  gl_GlobalInvocationID.z * globalSize.x * globalSize.y + gl_GlobalInvocationID.y * globalSize.x + gl_GlobalInvocationID.x - 1;
uint rightCellID = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + gl_GlobalInvocationID.y * globalSize.x + gl_GlobalInvocationID.x + 1;

#define LEFT_ID leftCellID
#define RIGHT_ID rightCellID
#define UP_ID upperCellID
#define DOWN_ID bottomCellID
#define FRONT_ID frontCellID
#define BACK_ID backCellID

float getNeighborVel(CellData cell, int direction) {
    switch (direction) {
        case LEFT:
        return float(cell.velocity.x < 0) * cell.velocity.x;
        case RIGHT:
        return float(cell.velocity.x > 0) * cell.velocity.x;
        case UP:
        return float(cell.velocity.y > 0) * cell.velocity.y;
        case DOWN:
        return float(cell.velocity.y < 0) * cell.velocity.y;
        case FRONT:
        return float(cell.velocity.z < 0) * cell.velocity.z;
        case BACK:
        return float(cell.velocity.z > 0) * cell.velocity.z;
    }
    return 0;
}
const float waterWeight = 1;

float positive(float value) {
    return value * float(value > 0);
}

vec3 positive(vec3 value) {
    return vec3(positive(value.x), positive(value.y), positive(value.z));
}

float negative(float value) {
    return value * float(value < 0);
}

vec3 negative(vec3 value) {
    return vec3(negative(value.x), negative(value.y), negative(value.z));
}

void main() {
    uint myCellID = (gl_GlobalInvocationID.z * globalSize.x * globalSize.y)+ (gl_GlobalInvocationID.y * globalSize.x) + gl_GlobalInvocationID.x;
    uint invocationCount = globalSize.x * globalSize.y * globalSize.z;
    if (myCellID >= invocationCount){
        return;
    }

    const vec3 cellVelocity = writeCells[myCellID].velocity;
    const vec3 reflectA = infoCells[myCellID].reflectA.xyz;
    const vec3 reflectB = infoCells[myCellID].reflectB.xyz;
    vec3 out_velocityPlus = positive(cellVelocity) + reflectA;
    vec3 out_velocityMinus = negative(cellVelocity) + reflectB;

    float outLength = length(out_velocityMinus) + length(out_velocityPlus);
    float outRatio = float(outLength > readCells[myCellID].fluidVolume) * readCells[myCellID].fluidVolume / (outLength + 0.000001) + float(outLength <= readCells[myCellID].fluidVolume);
    out_velocityPlus *= outRatio;
    out_velocityMinus *= -outRatio;
    outLength *= outRatio;
    vec3 in_velocityPlus;
    vec3 in_velocityMinus;

    writeCells[myCellID].fluidVolume = readCells[myCellID].fluidVolume * (1.0f - outLength);


    writeCells[UP_ID].fluidVolume += readCells[myCellID].fluidVolume * out_velocityPlus.y;
    writeCells[DOWN_ID].fluidVolume += readCells[myCellID].fluidVolume * out_velocityMinus.y;
    writeCells[LEFT_ID].fluidVolume += readCells[myCellID].fluidVolume * out_velocityMinus.x;
    writeCells[RIGHT_ID].fluidVolume += readCells[myCellID].fluidVolume * out_velocityPlus.x;
    writeCells[FRONT_ID].fluidVolume += readCells[myCellID].fluidVolume * out_velocityMinus.z;
    writeCells[BACK_ID].fluidVolume += readCells[myCellID].fluidVolume * out_velocityPlus.z;


    /*writeCells[myCellID].fluidVolume = max(readCells[myCellID].fluidVolume
    - readCells[myCellID].fluidVolume * (abs(writeCells[myCellID].velocity.x) + infoCells[LEFT_ID].reflectA.x - infoCells[RIGHT_ID].reflectB.x) * waterWeight
    - readCells[myCellID].fluidVolume * (abs(writeCells[myCellID].velocity.y) + infoCells[UP_ID].reflectA.y - infoCells[DOWN_ID].reflectB.y) * waterWeight
    - readCells[myCellID].fluidVolume * (abs(writeCells[myCellID].velocity.z) + infoCells[BACK_ID].reflectA.z - infoCells[FRONT_ID].reflectB.z) * waterWeight,
    0);

    writeCells[myCellID].fluidVolume += max(
    min(readCells[UP_ID].fluidVolume / 2,
    readCells[UP_ID].fluidVolume
    * (-writeCells[UP_ID].velocity.y + infoCells[UP_ID].reflectA.y) * waterWeight
    * float(writeCells[UP_ID].velocity.y < 0 || infoCells[UP_ID].reflectA.y > 0)), 0);

    writeCells[myCellID].fluidVolume += max(
    min(readCells[DOWN_ID].fluidVolume / 2,
    readCells[DOWN_ID].fluidVolume
    * (writeCells[DOWN_ID].velocity.y - infoCells[DOWN_ID].reflectB.y) * waterWeight
    * float(writeCells[DOWN_ID].velocity.y > 0 || infoCells[DOWN_ID].reflectB.y < 0)), 0);

    writeCells[myCellID].fluidVolume += max(
    min(readCells[LEFT_ID].fluidVolume / 2,
    readCells[LEFT_ID].fluidVolume
    * (writeCells[LEFT_ID].velocity.x + infoCells[LEFT_ID].reflectA.x) * waterWeight
    * float(writeCells[LEFT_ID].velocity.x > 0 || infoCells[LEFT_ID].reflectA.x > 0)), 0);

    writeCells[myCellID].fluidVolume += max(
    min(readCells[RIGHT_ID].fluidVolume / 2,
    readCells[RIGHT_ID].fluidVolume
    * (-writeCells[RIGHT_ID].velocity.x - infoCells[RIGHT_ID].reflectB.x) * waterWeight
    * float(writeCells[RIGHT_ID].velocity.x < 0 || infoCells[RIGHT_ID].reflectB.x < 0)), 0);

    writeCells[myCellID].fluidVolume += max(
    min(readCells[FRONT_ID].fluidVolume / 2,
    readCells[FRONT_ID].fluidVolume
    * (writeCells[FRONT_ID].velocity.z + infoCells[FRONT_ID].reflectA.z) * waterWeight
    * float(writeCells[FRONT_ID].velocity.z > 0 || + infoCells[FRONT_ID].reflectA.z > 0)), 0);

    writeCells[myCellID].fluidVolume += max(
    min(readCells[BACK_ID].fluidVolume / 2,
    readCells[BACK_ID].fluidVolume
    * (-writeCells[BACK_ID].velocity.z - infoCells[BACK_ID].reflectB.z) * waterWeight
    * float(writeCells[BACK_ID].velocity.z < 0 || infoCells[BACK_ID].reflectB.z < 0)), 0);*/


    if (bool(infoCells[myCellID].flags & CELL_SOURCE)){
        writeCells[myCellID].fluidVolume = maximumCellVolume;
    }
    if (bool(infoCells[myCellID].flags & CELL_SINK)){
        writeCells[myCellID].fluidVolume = 0.0;
    }
}
